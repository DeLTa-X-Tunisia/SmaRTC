# Technical Note: JWT Claim Resolution

## 1. The Problem: `System.FormatException` in `SessionController`

During end-to-end testing, the "Create Session" endpoint (`POST /api/session`) consistently failed with a `500 Internal Server Error`.

**Investigation:**
- The `api` container logs revealed a `System.FormatException: Input string was not in a correct format.`
- The error originated in the `CreateSession` method of the `SessionController`.
- The failing line was `var creatorId = Int32.Parse(User.FindFirstValue(ClaimTypes.NameIdentifier));`.

This indicated that the `NameIdentifier` claim, which was expected to contain a numeric User ID, was instead populated with a non-numeric string (the username).

## 2. The Root Cause: ASP.NET Core Default Claim Mapping

The root cause was the default behavior of the ASP.NET Core JWT Bearer authentication middleware. By default, it performs a mapping of inbound JWT claims to Microsoft's proprietary claim types.

- The JWT generated by `AuthController` correctly set the `sub` (Subject) claim to the numeric `user.Id`.
- However, upon receiving and validating the token, the middleware would automatically map the `sub` claim to `http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier` (represented by `ClaimTypes.NameIdentifier`).
- Crucially, it also mapped the `unique_name` claim (which held the username) to the same `NameIdentifier` claim, overwriting the numeric ID with the username string.

This resulted in `User.FindFirstValue(ClaimTypes.NameIdentifier)` returning the username, causing the `Int32.Parse` to fail.

## 3. The Solution: A Two-Part Fix

A robust, two-part solution was implemented to ensure claim integrity.

### Part 1: Disable Default Inbound Claim Mapping

In `api/Program.cs`, the default claim mapping was explicitly disabled. This is the most critical step and is considered a best practice to prevent unexpected claim transformations.

```csharp
// In builder.Services.AddAuthentication(...).AddJwtBearer(...)
// ...

// Prevent the JWT middleware from re-mapping claims
JwtSecurityTokenHandler.DefaultInboundClaimTypeMap.Clear();

builder.Services.AddAuthentication(options =>
{
    // ...
})
.AddJwtBearer(options =>
{
    options.TokenValidationParameters = new TokenValidationParameters
    {
        // ...
    };
});
```

### Part 2: Explicit and Redundant Claim Generation

In `api/Controllers/AuthController.cs`, the `GenerateJwtToken` method was updated to be more explicit and resilient. It now sets **both** the `sub` and `NameIdentifier` claims directly to the user's numeric ID.

While disabling the claim map (Part 1) is the primary fix, this defensive measure ensures that the token is unambiguous about the user's identity, regardless of middleware behavior.

```csharp
// In AuthController.cs -> GenerateJwtToken(User user)

var claims = new[]
{
    new Claim(JwtRegisteredClaimNames.Sub, user.Id.ToString()),
    new Claim(ClaimTypes.NameIdentifier, user.Id.ToString()), // Explicitly set NameIdentifier
    new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()),
    new Claim(JwtRegisteredClaimNames.UniqueName, user.Username)
};
```

## 4. Validation

After implementing this two-part fix and rebuilding the `api` service, the `test-api.ps1` script was re-run.

- **Result:** The "Create Session" test passed with a `201 Created` status.
- **Confirmation:** The response body confirmed that the `creatorId` in the newly created session object correctly matched the numeric ID of the authenticated user.

This fix permanently resolved the authentication issue and stabilized the API platform.
